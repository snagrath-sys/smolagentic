# -*- coding: utf-8 -*-
"""processes-agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qb-DKElD3uuwfitrXhpn43xGL5B1iPhX
"""

!pip install python-dotenv==1.0.1
!pip install google-auth smolagents[litellm]
!pip install llama-index-tools-google llama-index-llms-gemini llama-index-embeddings-gemini

from smolagents import LiteLLMModel

from google.colab import userdata

# Replace all calls to HfApiModel
llm_model = LiteLLMModel(
    model_id="gemini/gemini-2.0-flash", # you can see other model names here: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models. It is important to prefix the name with "gemini/"
    api_key=userdata.get('GEMINI_API_KEY'),
    max_tokens=8192
)

from smolagents import CodeAgent, HfApiModel, FinalAnswerTool, Tool, tool

@tool
def checkout_project(name: str, project: str) -> str:
    """
    Checks out a project using the bb CLI tool.

    Args:
        name: The name of the project instance to create.
        project: The label of the project to check out.
    """
    import subprocess

    try:
        command = ["bb", "create", "-x", name, "-l", project]
        result = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return f"Project checkout successful:\n{result.stdout}"
    except subprocess.CalledProcessError as e:
        return f"Error during checkout:\n{e.stderr}"

@tool
def create_python_file(filename: str) -> str:
    """
    Creates a new Python (.py) file with the given name.

    Args:
        filename: Name of the file to create, should end with .py
    """
    if not filename.endswith(".py"):
        return "Error: Filename must end with .py"

    try:
        with open(filename, 'w') as f:
            f.write("#!/usr/bin/env python3\n\n")
            f.write("def main():\n    pass\n\n")
            f.write("if __name__ == '__main__':\n    main()\n")
        return f"Python file '{filename}' created successfully."
    except Exception as e:
        return f"Error creating file: {e}"

import os
import shutil
import subprocess

@tool
def create_directory_and_move_file(dir_name: str, file_to_move: str) -> str:
    """
    Creates a new directory and moves a specified file into it.

    Args:
        dir_name: Name of the new directory to create.
        file_to_move: Path to the file that should be moved into the directory.
    """
    try:
        os.makedirs(dir_name, exist_ok=True)
        destination = os.path.join(dir_name, os.path.basename(file_to_move))
        shutil.move(file_to_move, destination)
        return f"File '{file_to_move}' moved to directory '{dir_name}'."
    except Exception as e:
        return f"Error: {e}"

@tool
def copy_file(source_file: str, destination_path: str) -> str:
    """
    Copies a file to a given destination path.

    Args:
        source_file: Path to the file to copy.
        destination_path: Path where the file should be copied to.
    """
    try:
        shutil.copy(source_file, destination_path)
        return f"File '{source_file}' copied to '{destination_path}'."
    except Exception as e:
        return f"Error: {e}"

@tool
def delete_file(file_path: str) -> str:
    """
    Deletes a given file.

    Args:
        file_path: Path to the file to delete.
    """
    try:
        os.remove(file_path)
        return f"File '{file_path}' has been deleted."
    except FileNotFoundError:
        return f"Error: File '{file_path}' not found."
    except Exception as e:
        return f"Error: {e}"

@tool
def create_symbolic_link(source: str, link_name: str) -> str:
    """
    Creates a symbolic link pointing from link_name to source.

    Args:
        source: The source file path.
        link_name: The path where the symlink should be created.
    """
    try:
        os.symlink(source, link_name)
        return f"Symbolic link created: {link_name} -> {source}"
    except Exception as e:
        return f"Error creating symbolic link: {e}"

@tool
def delete_folder(folder_path: str) -> str:
    """
    Deletes a folder and all its contents in the current environment.

    Args:
        folder_path: The path to the folder to delete.
    """
    try:
        if not os.path.exists(folder_path):
            return f"Folder '{folder_path}' does not exist."
        if not os.path.isdir(folder_path):
            return f"'{folder_path}' is not a directory."

        shutil.rmtree(folder_path)
        return f"Folder '{folder_path}' and all its contents have been deleted."
    except Exception as e:
        return f"Error deleting folder: {e}"

@tool
def find_file_in_project(file_name: str) -> str:
    """
    Recursively searches for a file with the given name in the current project directory.

    Args:
        file_name: The name of the file to search for.
    """
    matching_paths = []
    for root, dirs, files in os.walk("."):
        if file_name in files:
            full_path = os.path.join(root, file_name)
            matching_paths.append(full_path)

    if matching_paths:
        return "Found file(s):\n" + "\n".join(matching_paths)
    else:
        return f"No file named '{file_name}' found in the project."

find_file_in_project("tester_new_copy1.py")

agent = CodeAgent(
    tools=[checkout_project, create_python_file, create_directory_and_move_file, copy_file, delete_file, create_symbolic_link, find_file_in_project],
    model=llm_model,
    max_steps=10,
    verbosity_level=2
)



agent.run('''Delete the folder tester_root_dir.
            Create a new file named tester_new.py, place it in a directory called tester_root_dir.
            Make 3 copies of this file name them by appending the new file name with the copy number.
          ''')

agent.run("Delete the files tester_new_copy1.py tester_new_copy2.py tester_new_copy3.py")

